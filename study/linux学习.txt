ps -ef | grep python   查看指定进程
ipconfig   查询本机的网络信息属性
arp -a   查询同一局域网的所有主机ip
net view 查询局域网主机名称
ln -s (文件位置)    创建软链接
mv  移动文件/重命名文件
mknod pwd b/c(字符/块) major minor    创建设备节点
rm -rf /dev/...
man  函数名   查看c函数的用法
chmod +x ./test.sh  #使脚本具有执行权限
df -h 查看磁盘空间
/bin/sh test.sh   解释器直接运行脚本
expr  表达式计算公式
变量名和等号之间不能有空格
记录时间  `data +%s`   前空格后无空格

repo init -u ssh://caoyong@10.12.130.33:29418/metis-station/manifest -b metis-dev --repo-url=ssh://caoyong@10.12.130.33:29418/tools/git-repo
repo sync -cdj4 --no-tags

return   -EFAULT;   //errno:14   地址错
return   -EAGAIN;   //errno:11   资源暂时不可用
return   -EINTR;   //errno:4     中断的函数调用
return   -ESPIPE     //errno:29   无效的文件指针重定位
return   -ENOTTY;//errno:25     不适当的IO控制操作

重点内容：.owner = THIS_MODULE为什么加“点”的原因
这种方式称为指定初始化  源自ISO C99标准 初始化不必严格按照定义时的顺序
代码分析：int register_blkdev(unsigned int major, const char *name);major 参数是块设备要使用的主设备号，
name为设备名，它会在/proc/devices中被显示。 如果major为0，
内核会自动分配一个新的主设备号register_blkdev()函数的返回值就是这个主设备号。如果返回1个负值，表明发生了一个错误。
kmalloc和vmalloc的区别
1、kmalloc保证分配的内存在物理上是连续的,vmalloc保证的是在虚拟地址空间上的连续
2、kmalloc能分配的大小有限,vmalloc能分配的大小相对较大
3、vmalloc比kmalloc要慢
4、kmallloc使用的是slab内存分配机制，而vmalloc使用的是伙伴系统分配机制，这也是造成它们区别的根本所在

typedef  long long  loff_t
typedef  unsigned int dev_t
long(64)/int(32)   ssize_t
unsigned long/unsigned int size_t

char数组不能设置过大，会出现乱码
unlocked_ioctl:  long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
ioctl: int(*ioctl) (struct inode *,struct file *, unsigned int, unsigned long);

inode  文件编号 
nd -> i_rdev    文件所代表的设备号    i_dev  所在设备的主设备号和此设备号信息
major: 

c预处理器（C Preprocessor） CPP, 文本替换工具
预处理指令都是以#开头，在实际编译之前替换成编译器能识别的代码
#define 定义宏    可以模拟函数
预定义宏：编译器事先设定好的宏： __DATE__  __TIME__   __FILE__  __LINE__
宏中    \  # ##  defined()

错误处理：
erron（整数），perror，strerror,  错误输出文件流：stderr
fprintf(stderr，“”）
perror（“..”）

函数参数数量可变 stdarg.h
动态分配内存：calloc，malloc
char *description = （char*）malloc（200 * sizeof（char））；
释放内存：free
重新分配内存：realloc

命令行参数 int main(int argc, char *argv[])
argc 参数个数， argv[]指针数组，指向传递给程序的每个参数
没有任何参数时argc是1，argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针
 
在ram上运行驱动：/usr/src/....
Ubuntu上会产生许多文件:
kernel_hello.c 
kernel_hello.o
Makefile
kernel_hello.ko
kernel_hello.mod
kernel_hello.mod.c
kernel_hello.mod.o
Module.symvers
modules.order

RAM上运行驱动位置：/usr/src/linux-headers-$(shell uname -r)
在pc上运行驱动位置：/lib/modules/$(shell uname -r)/build
   
服务器分为数据服务器和应用服务器

Makefile语法：
.PHONY： 指定伪目标（不管是否存在相同名称文件，该目标一定执行）
make -f rules.txt  // make --file=rules.txt   默认执行Makefile文件，当没有时指定txt文件并使用其中的规则
= 是最基本的赋值
:= 是覆盖之前的值
?= 是如果没有被赋值过就赋予等号后面的值
+= 是添加等号后面的值
加@ 在命令行不显示
clear，clean等指令要写在Makefile文件中，之后才能make clear/n
$(MAKE) -C $(KERNELDIR) M = $(CURRENT_PATH) modules   创建模块ko
$(MAKE) -C $(KERNELDIR) M = $(CURRENT_PATH) clean        删除模块创建产生的一系列文件
默认执行第一个目标操作  XXX：   相当于语言中的主函数
第一行直接写操作名称即可不用加make，如果换行，则需要用make + 操作名称
例如   caoyong：kernel_modules
	          make clear  （后面的操作需要加上make)
                          。。。

printk(KERN_ALERT "Hello, caoyong IoT Studio!\n");
printk函数的参数有0-7八个级别，默认为4
#define 	KERN_EMERG  	"<0>"   系统(不使用)	               /* system is unusable        */
#define 	KERN_ALERT  	"<1>"   立即执行(操作系统使用) /* action must be taken immediately */
#define 	KERN_CRIT   	"<2>"   紧急情况(临界条件)       /* critical conditions          */
#define 	KERN_ERR    	"<3>"   错误	               /* error conditions            */
#define 	KERN_WARNING      "<4>"   警告	               /* warning conditions       */
#define 	KERN_NOTICE 	"<5>"   提示	               /* normal but significant condition */
#define 	KERN_INFO   	"<6>"   正常打印	               /* informational               */
#define 	KERN_DEBUG  	"<7>"   调试	               /* debug-level messages  */

在使用设备树时我们将**.dts文件利用dtc编译器编译为**.dtb文件。
在已知**.dtb文件的情况下我们有两种方法可以得到dts源码：
方法一：使用fdtdump工具进行反汇编
           使用命令：root#fdtdump **.dtb > temp.dts
           反汇编生成的内容保存在temp.dts
方法二：使用dtc编译器进行反汇编
           dtc -h 可以产看dtc命令的帮助
           使用命令：root# dtc -I dtb -O dts -o temp1.dts s5pv210-smdkv210.dtb

功能	函数原型
打开文件	struct file *filp_open(const char *filename, int flags, int mode)
读取文件	ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
写文件	ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
关闭文件	int filp_close(struct file *filp, fl_owner_t id)
pos会随着读写变化


window命令行 ：
dir  查看当前目录下的文件和文件夹
mdir，md  创建文件夹
echo  向文件中输入
type   查看文件
copy  复制文件
rename  move del

vscode:
ctrl + shift + p  直接调出命令面板